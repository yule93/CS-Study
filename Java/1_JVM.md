# JVM(Java Virtual Machine)
Java가 환경에 관계 없이 작동할 수 있도록 도와주는 가상 머신. **자바 코드를 바이트 코드(클래스 파일)로 변환해 컴퓨터가 수행할 수 있게 해주고 프로그램 메모리를 관리하고 최적화한다.**

## JVM의 특징
- 스택 기반의 가상머신
- GC(Garbage Collection)
- 플랫폼에 독립적

Java와 OS 사이 중재자 역할을 하기 때문에 CPU나 운영체제의 종류와 기기 종류에 구애받지 않고 재사용이 가능하게 해준다.

**한정된 메모리를 효율적으로 사용해 최고의 성능을 내준다.** 보통 이 성능에 혁혁한 공을 세우는 게 GC이다.

## 자바의 구동 원리
<img src = "https://velog.velcdn.com/images%2Fsuwon-city-boy%2Fpost%2F90bc8cd6-8573-4120-be92-63b867a70998%2Fjvm%EC%8B%A4%ED%96%89%EA%B3%BC%EC%A0%95.jpg" width = "50%">

  1) JVM이 OS로부터 메모리를 할당받고 용도에 따라 여러 영역으로 나눈다.
  2) JVM 내 Java Compiler가 java 코드를 byte code로 변환한다.
  3) Class Loadder System으로 Class 파일을 JVM에 로딩한다.
  4) 로딩된 클래스 파일들은 Execution Engine을 통해 해석되며 Runtime Data Areas에 배치된다.

      4-1) Execution Engine 내에 있는 GC가 동작하며 새로 들어온 명령어/여러번 쓰인 명령어인지 구별해서 Eden, Old에 적재된다.
  
  5) RDA에 배치된 파일들은 실질적 수행을 진행한다. Thread Synchronization이 일어나는 구간이기도 하다.

## JVM 구성 요소
<img src = "https://velog.velcdn.com/images%2Fsuwon-city-boy%2Fpost%2F18236f60-dfac-4239-a86c-af892c68b0a8%2Fjvm%20%EA%B5%AC%EC%A1%B0.png" width = "50%">

### Class Loader
런타임 시 JVM 내로 클래스 파일을 로드하고 링크를 통해 배치한다. 사용하지 않은 클래스들은 메모리에서 삭제하고 동적 로드를 담당한다.
- 로딩: .class를 읽음
- 링크: 코드 내부 레퍼런스 연결
- 초기화: 클래스에 있는 static(전역 변수) 초기화

### Execution Engine: 실행 엔진
클래스를 실행시키는 역할로 Runtime Data Area에 배치시킨 바이트 코드를 실행한다. 이 때, 자바 바이트 코드는 Low-level(기계어, 어셈블리어) 언어는 아니다. 따라서 **실행 엔진은 다시 한 번 더 바이트 코드를 기계가 실행할 수 있는 형태(보통 2진수 숫자겠죠)로 변경한다.**

실행 엔진은 바이트 코드를 명령어 단위로 읽어서 실행하는데 **인터프리터 방식**과 **JIT 컴파일러 방식**이다. 인터프리터가 느려서 보완 방식으로 JIT 컴파일러 방식을 개발했다.

1) Interpreter(인터프리터)
  - 바이트 코드를 명령어 단위로 읽어서 실행하는데 한 줄씩 실행해서 느리다.

2) JIT(Just In Time) 컴파일러
  - 인터프리터 방식으로 실행하다 적절한 시점에 바이트 코드 전체를 컴파일 해 네이티브 코드로 바꾸고, 이후에 인터프리팅 과정 없이 직접 실행하는 방식
  - 네이티브 코드는 캐시에 보관해서 엄청 빠르다.
  - 한 번만 실행되는 코드라면 인터프리터 방식이 더 유리하다. 즉, **여러번 수행되는 클래스 파일일 때 사용하는 게 좋다.**

3) Garbage Collector
  - GC를 실행하는 모듈이다. 더 이상 참조되지 않는 객체를 모아서 메모리를 정리한다.
  - 경우에 따라 성능 효율을 위해 커스터마이징이 필요하다.
  - GC에 대한 자세한 설명은 [여기](\2_Garbage_Collection.md)

### 메모리
**힙과 메소드는 전체 공유 자원**이고 **스택, PC, 네이티브 메소드 스택은 Thread 단위 자원**이다.
- 메소드: 클래스 수준의 정보를 저장한다. 클래스 이름, 부모 클래스 이름, 메소드, 변수 등 static도 저장한다.
- 힙: 객체(인스턴스) 수준의 정보를 저장한다.
- 스택: 인스턴스 및 지역 변수의 참조 주소를 저장한다. 스레드마다 런타임 스택을 만들고 스택 프레임(메소드 콜)을 쌓는다. 에러가 났을 때 런타임 스택에 쌓인 메시지가 출력되는 걸 볼 수 있다.
- PC: 스레드마다 가진 Program Counter. **현재 실행할 부분을 가리킨다.**
- 네이티브 메소드 스택: 네이티브 메소드를 호출할 때 쓰는 별도의 스택. c와 같은 Low-level 언어로 구현된 메소드이다.


## 참고 자료
[JVM+특징+구조+실행과정](https://velog.io/@suwon-city-boy/JVM%EC%9D%98-%ED%8A%B9%EC%A7%95-%EA%B5%AC%EC%A1%B0-%EC%8B%A4%ED%96%89%EA%B3%BC%EC%A0%95)